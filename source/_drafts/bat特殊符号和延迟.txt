设置本地为延迟扩展。其实也就是：延迟变量，全称延迟环境变量扩展, 想进阶，变量延迟是必过的一关！所以这一部分希望你能认真看。

为了更好的说明问题，我们先引入一个例子。
例1:
?
1
2
3
4
@echo off 
set a=4 
set a=5&echo %a% 
pause
结果：4
解说：为什么是4而不是5呢？在echo之前明明已经把变量a的值改成5了？让我们先了解一下批处理运行命令的机制：批处理读取命令时是按行读取的（另外例如for命令等，其后用一对圆括号闭合的所有语句也当作一行），在处理之前要完成必要的预处理工作，这其中就包括对该行命令中的变量赋值。我们现在分析一下例1，批处理在运行到这句“set a=5&echo %a%”之前，先把这一句整句读取并做了预处理——对变量a赋了值，那么%a%当然就是4了！（没有为什么，批处理就是这样做的。）而为了能够感知环境变量的动态变化，批处理设计了变量延迟。简单来说，在读取了一条完整的语句之后，不立即对该行的变量赋值，而会在某个单条语句执行之前再进行赋值，也就是说“延迟”了对变量的赋值。那么如何开启变量延迟呢？变量延迟又需要注意什么呢？

举个例子说明一下：

例2:

?
1
2
3
4
5
@echo off 
setlocal enabledelayedexpansion 
set a=4 
set a=5&echo !a! 
pause
结果：5
解说：由于启动了变量延迟，得到了正确答案。变量延迟的启动语句是“setlocal enabledelayedexpansion”，并且变量要用一对叹号“!!”括起来（注意要用英文的叹号），否则就没有变量延迟的效果。分析一下例2，首先“setlocal enabledelayedexpansion”开启变量延迟，然后“set a=4”先给变量a赋值为4，“set a=5&echo !a!”这句是给变量a赋值为5并输出（由于启动了变量延迟，所以批处理能够感知到动态变化，即不是先给该行变量赋值，而是在运行过程中给变量赋值，因此此时a的值就是5了）。再举一个例子巩固一下。
例3:

?
1
2
3
4
@echo off 
setlocal enabledelayedexpansion 
for /l %%i in (1,1,5) do ( set a=%%i echo !a! ) 
pause
结果：12345

解说：本例开启了变量延迟并用“!!”将变量扩起来，因此得到我们预期的结果。如果不用变量延迟会出现什么结果呢？结果是这样的：ECHO 处于关闭状态。ECHO 处于关闭状态。ECHO 处于关闭状态。ECHO 处于关闭状态。ECHO 处于关闭状态。即没有感知到for语句中的动态变化。

batman的说明
我来简要说一下吧：
set：设置
local：本地（环境变量）
enable：能够
delayed：延迟
expansion：扩展
setlocal enabledelayedexpansion就是扩展本地环境变量延迟，
比较下面两段代码：

?
1
2
3
4
5
6
@echo off 
for /l %%i in (1,1,10) do ( 
set "str=%%i"
echo %str% 
) 
pause>nul
?
1
2
3
4
5
6
@echo off&setlocal enabledelayedexpansion 
for /l %%i in (1,1,10) do ( 
set "str=%%i"
echo !str! 
) 
pause>nul
第一段代码只会显示10行“ECHO 处于关闭状态。”，而第二段代码则会正确显示1－10的10行数字。这是为什么呢？因为在两段代码的for循环前str都是没有被定义的，而由于第一段代码没有开启变量延迟，所以str值一直是没有定义，因而显示出了10行报
错信息；而第二段代码开启了变量延迟，在for循环中每次赋予str的值被传递下去，因而会正确显示10行数字，但这里的str变量符必须要写成!str!，这是没有道理可讲的，只要记住就好了。

setlocal enabledelayedexpansion 是什么意思？

是：设置本地为延迟扩展。其实也就是：延迟变量，全称"延迟环境变量扩展",
在cmd执行命令前会对脚本进行预处理，其中有一个过程是变量识别过程，在这个过程中，如果有两个%括起来的如%value%类似这样的变量，就会对其进行识别，并且查找这个变量对应的值，再而将值替换掉这个变量，这个替换值的过程,就叫做变量扩展，然后再执行命令。

在解释之前，先看几个例子的区别：
例一：
?
1
2
set value=kkkkkkk 
echo %value%
将这段代码保存到一个后缀为bat的文本文件中。然后打开dos，进到对应目录下，执行这个文件，结果如下：
C:\Documents and Settings\Administrator\桌面\ln\temp\bat>set value=kkkkkkk
C:\Documents and Settings\Administrator\桌面\ln\temp\bat>echo kkkkkkk
kkkkkkk
最后一行是结果，但是在结果之前，还有两句，set value=kkkkkkk 和 echo kkkkkkk，但是在语句中，我们并没有写echo kkkkkkk的语句，这表明至少在执行到echo %value% 这句时，对变量进行的值的替换。这就是变量的扩展。
那么什么是变量的延迟扩展呢？
如果大家知道C++的“静态变量”概念，那就应该知道，c++编译的时候，会对静态变量进行值的替换，但这个替换是基于静态的前提下，那么进行变量扩展时，也是这样，但如果出现动态的情况会怎样？在cmd执行中，发生动态的一种情况是在 for语句中进行变量赋值，例如：
例二：

?
1
2
3
4
5
@echo off 
for /l %%i in (1,1,3) do ( 
set k=%%i ::对k进行循环赋值 
echo %k% %%i 
)

执行这样的脚本，出现如下结果：
_1
_2
_3
结果出现这三句话。_ 表示空格
注：k没有赋初值，则替换为空。

例三：
?
1
2
3
4
5
6
@echo off 
set k=yyy 
for /l %%i in (1,1,3) do ( 
set k= %%i ::对k进行循环赋值 
echo %k% %%i 
)

结果:
yyy 1
yyy 2
yyy 3
注：k有赋初值，则都替换为yyy。、
实例四：
?
1
2
3
4
5
6
7
@echo off 
setlocal enabledelayedexpansion 
set k= 3 
for /l %%i in (1,1,3) do ( 
set k=%%i 
echo %k% %%i 
)
结果：
3 1
3 2
3 3
这里已经是用了延迟变量，为什么还会出现这种情况呢？再看实例五：
实例五：
?
1
2
3
4
5
6
7
@echo off 
setlocal enabledelayedexpansion 
set k= 3 
for /l %%i in (1,1,3) do ( 
set k=%%i 
echo !k! %%i 
)
结果：
1 1
2 2
3 3
原来在延迟变量扩展中，要使用！来引用变量。


批处理常用符号详解
这是一篇针对批处理中常用符号的详细解释，每个符号都有解释及相应的举例，希望通过比较系统的讲述，能让新手尽快入门。

　　在这篇帖子中，我对常用符号的讲解做如下限定：
　　1、收集批处理中经常用到的符号；
　　2、每个常用符号，只讲述最常用的功能；深入的用法留待将来介绍；
　　这样限定的原因，一是让新手系统地接触最常用符号的常用功能，不至于一开始就陷入技术细节中难以自拔；二是有些符号的用法非常罕见，没有特定的需求可以忽略掉，比如句柄复制符号；三是有些高深的内容本人也没有完全消化，只解说一鳞半爪难免会误人子弟，比如 set /a 中的^、!等符号；

　　如有遗漏或谬误，请大家及时跟帖，帮忙修正。
————————————————————————————————————————————

1、@
　　一般在它之后紧跟一条命令或一条语句，则此命令或语句本身在执行的时候不会显示在屏幕上。请把下面的代码保存为test.cmd文件，然后运行，比较一下两条echo语句在屏幕上的输出差异：
echo a
@pause
@echo b
@pause
复制代码
执行结果如下：
C:\Documents and Settings\JM\桌面>echo a
a
请按任意键继续...
b
请按任意键继续...


2、%、%%
　　百分号用在不同的场合，有不同的含义：
　　① 当百分号成对出现，并且其间包含非特殊字符时，一般做变量引用处理，比如：%var%、%str%。把以下代码保存为批处理文件，运行后观察屏幕显示结果：
@echo off
set str=abc
echo 变量 str 的值是： %str%
pause
复制代码
在屏幕上将显示这样的结果：
变量 str 的值是： abc
按任意键继续...

　　另外，百分号作为变量引用还有一种特殊形式，那就是对形式参数的引用，此时，单个百分号后面紧跟0～9这10个数字，如%0、%1，请看演示代码：
@echo off
if defined str goto next
set str=
set /p str=请把文件拉到本窗口后回车：
call "%~0" %str%
pause
exit

:next
cls
echo 本批处理文件完整路径为："%~0"
echo 拖到本窗口的文件完整路径为："%~1"
goto :eof
复制代码
② 出现在 set /a 语句中时，表示两数相除取余数，也就是所谓的模运算，它在命令行窗口和批处理文件中的写法略有差异：在命令行窗口中，只需要单个的%，在批处理文件中，需要连续两个百分号，写成%%。
　　例如：在命令行窗口中，运行 set /a num=4%2 ，则结果将显示0，因为4除以2的余数为0；如果保存为批处理文件，则此语句将略有改变：
@echo off
set /a num=4%%2
echo 4除以2的余数为 %num%
pause
复制代码
③ 转义符号：如果要显示%本身时，需要在前面用%来转义。例如：
@echo off
echo 一个百分号：%%
echo 两个百分号：%%%%
echo 三个百分号：%%%%%%
pause
复制代码
3、:、::
　　① 以:打头的单个的:表示该行是一个标签，它之后的内容是一个标签段，如:test，则表示:test之下的内容是标签段，而test是这个标签段的名，可以用 goto test 、goto :test 跳转到该标签段或用 call :test 调用该子过程；而连续两个冒号打头表示该行内容为注释内容，实际上，:: 是个无效的标签名，:加上空格同样可以起到注释的作用，此时，::的功能和注释命令rem相同；但是，rem 注释语句中的某些命令符号如重定向符号和管道符号还是会执行，而如果用::来注释的时候，与::同处一行的所有命令或符号直接被命令解释器忽略掉，无形中提高了注释的兼容性和整个程序的执行效率，并且在众多的命令语句中更显得醒目，所以，注释语句推荐使用::的格式。
　　② 在 set 语句中：和~同时使用时，: 起到截取字符串的功能。假设 set str=abcde，那么，set var=%str:~0,1% 表示截取字符串abcde的第一个字符；和=同时使用时，起到替换字符串的功能。假设：set str=abc:de，那么，set var=%str:a=1% 则表示把字符串abc:de中的a替换为1，set var=%str::=2% 则表示把字符串abc:de中的:替换为2；

4、~
　　① 用在 set 语句中，和:同时使用时，起到截取字符串的功能，请参考上一条的解释；
　　② 用在 set /a 语句中时，它是一元运算符号，表示将操作数字按位取反，例如，set /a num=~1的执行结果是-2，set /a num=~0的结果是-1
　　③ 用在for语句中，表示增强for的功能，能够提取到更多的信息。例如：在批处理文件的for语句中：%%~i表示去掉第一对外侧引号，%%~zi表示获取文件的大小(以字节为单位)，%%~ni表示获取文件名，%%~xi表示获取扩展名(带点号)……它们可以组合使用，如%%~nxi表示获取文件名和后缀名。

5、>、>>
　　一般而言，>表示用新内容覆盖原文件内容，>>表示向原文件追加内容，此时，它们以重定向符号的身份出现；如果用在 set /a 语句中，则>表示分组，>>表示逻辑移位；

6、|
　　一般而言，它以管道符号的身份出现，表示把在它之前的命令或语句的执行结果作为在它之后的命令或语句的处理对象，简而言之，就是把它之前的输出作为它之后的输入，例如：echo abcd|findstr "b"，表示把echo abcd的执行结果，作为findstr "b" 的执行对象，也就是在字符串abcd中查找b字符；如果test.txt中有abcd字符串，则该语句与 findstr "b" test.txt 具有同样的效果；

7、^
　　一般而言，^以转义字符的身份出现。因为在cmd环境中，有些字符具备特殊功能，如>、>>表示重定向，|表示管道，&、&&、||表示语句连接……它们都有特定的功能，如果需要把它们作为字符输出的话，echo >、echo | ……之类的写法就会出错——cmd解释器会把它们作为具有特殊功能的字符对待，而不会作为普通字符处理，这个时候，就需要对这些特殊字符做转义处理：在每个特殊字符前加上转义字符^，因此，要输出这些特殊字符，就需要用 echo ^>、echo ^|、echo ^|^|、echo ^^……之类的格式来处理；

8、&
　　一般而言，&表示两条命令或语句同时执行的意思。如 echo a&echo b，将在屏幕上同时显示a和b字符。当几条语句含义近似或作用相同且没有先后的顺序之别时，启用&符号连接这些语句将会增加程序的可读性；

9、&&、||
　　这是一对含义截然相反的命令符，&&表示如果它之前的语句成功执行，将执行它之后的语句，而||则表示如果它之前的语句执行失败，将执行它之后的语句；在某些场合，它们能替代 if……else…… 语句；例如：
@echo off
md test&&echo 成功创建文件夹test||echo 创建文件夹test失败
pause
复制代码
效果等同于如下代码：
@echo off
md test
if "%errorlevel%"=="0" (echo 成功创建文件夹test) else echo 创建文件夹test失败
pause
复制代码
10、()
　　小括号对经常出现在for语句和if语句中，还有一些特定场合；在for和if语句中属于语句格式的要求，例如：
　　① for %%i in (语句1) do (语句2)：在这条语句中，语句1必须用括号对包围，而语句2的括号对则可视情况予以抛弃或保留：如果语句2是单条语句或用&、&&、||等连接符号连接的多条语句，括号对可以抛弃，如果语句2是有逻辑先后关系的多条语句集合，则必须保留括号对，并且，多条语句必须断行书写；例如：
@echo off
for %%i in (a b c) do echo %%i&echo --------
pause
复制代码
也可以改写为：
@echo off
for %%i in (a b c) do (
    echo %%i
    &echo --------
)
pause
复制代码
② if 条件 (语句1) else (语句2)：如果没有else部分，则语句1的括号对可有可无；如果有else部分，则语句1中的括号对必须保留，此时，语句2中的括号对保留与否，和上一点类似。例如：
@echo off
if exist test.txt echo 当前目录下有test.txt
pause
复制代码
@echo off
if exist test.txt (echo 当前目录下有test.txt) else echo 当前目录下没有test.txt
pause
复制代码
@echo off
if exist test.txt (echo 当前目录下有test.txt) else (
    echo 当前目录下没有test.txt
    pause
    cls
    echo 即将创建test.txt文件
    cd.>test.txt&&echo 成功创建test.txt
)
pause
复制代码
③ 特定场合下使用括号对，不但可以使代码逻辑清晰，增强可读性，还可能会减少代码量。比如用echo语句构造多行文本内容的时候：
@echo off
(
echo 第一行
echo 第二行
echo 第三行
)>test.txt
start test.txt
复制代码
如果不使用括号对的话，则需要使用如下代码：
@echo off
echo 第一行>test.txt
echo 第二行>>test.txt
echo 第三行>>test.txt
start test.txt
复制代码
11、+、-、*、/
　　在 set /a 语句中，这些符号的含义分别为：加、减、乘、除。例如：set /a num=1+2-3*4/5。需要注意的是，这些运算符号遵循数学运算中的优先级顺序：先乘除后加减，有括号的先算括号，并且，直接忽略小数点，因此，刚才那个算式的结果是1而不是0或0.6。
　　另外，有可能会在代码中看到这样的写法：set /a num+=1、set /a num-=1、set /a num*=1 和 set /a num/=1，这些表示累加、累减、累乘、累除，步长都是1，展开后的完整写法为：set /a num=num+1、set /a num=num-1、set /a num=num*1 和 set /a num=num/1(set /a 语句中，变量引用可以忽略百分号对或感叹号对，set /a num=%num%+1 与 set /a num=num+1 等同)

12、equ、neq、lss、leq、gtr、geq
　　这几个命令符是if语句中常用到的数值比较符号，取自英文的关键字母，具体的含义为：
命令符号        含义                英文解释
EQU                等于                equal
NEQ                不等于                 not equal
LSS                少于                 less than
LEQ                少于或等于         less than or equal
GTR                大于                 greater than
GEQ                大于或等于         greater than or equal